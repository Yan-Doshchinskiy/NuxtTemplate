## Problems and Solutions

Перед началом использования `Unit Test Module` нужно понять какие задачи мы решаем.

### 1. Структуризация
Вполне логично, что любой проект имеет свою четкую структуру.
Зачастую она диктуется проектной документацией и правилами используемого фреймворка.
Очень важно, чтобы структура была единой и понятной. 
В противном случае скорость разработки и нахождения ошибок может сильно замедлиться.

Это утверждение также применимо и к структуре Unit тестов.
Для тестирования на наших проектах применяется библиотека `Jest` в связке с `@vue/test-utils`. 
Они дают большой список возможностей для тестирования, но не сильно ограничивают имплементацию.
Поэтому все тесты могут быть написаны по-разному, и при необходимости внесения изменений в них будет сложно разобраться.

Для увеличения прозрачности хорошим решением будет разбить тесты каждого компонента на логические части, 
тестирующие лишь один набор св-в и методов компонента.

Данный подход также увеличит процент покрытия кода тестами,
т.к. четкая структура значительно понижает шанс пропустить при тестировании какой-либо функционал, 
встречающийся в каждом компоненте.

### 2. Набор базовых инструментов
При тестировании компонентов нам приходится использовать определенный набор функций и переменных.
Данная имплементация позволяет вынести часто используемый функционал в базовые классы `Utils`, 
в связи с чем он будет доступен во всех тестах. 

Этот подход позволяет вынести базовый функционал в классы, методы которых доступны в каждом тесте, 
в связи с чем будет соблюдаться принцип DRY и значительно сократится количество utility кода.

### 3. Типизация
Модуль достаточно гибко типизирован, мы можем устанавливать базовые интерфейсы при наследовании, 
в результате чего все указанные типы уже будут действовать на подклассы и св-ва.


### 4. Гибкость и расширяемость
При использовании единой архитектуры очень важно, чтобы её можно было гибко настраивать и расширять.
Данная имплементация предоставляет список инструментов,
позволяющих настроить вспомогательные классы `Utils` для каждого модуля.


### 5. Семантика
Классовый подход имеет достаточно весомый перевес в читаемости кода. 
Мы можем хранить данные в св-вах класса и изменять их с помощью методов, вместо того,
чтобы хранить их в переменных, объявленных через let и const. 
Например, мы можем хранить какие-либо значения в контексте класса и переопределять их внутри каждого теста, 
а также в методах beforeEach, afterEach и т.д..
